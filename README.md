# SprtaItemSimulator

<!-- TOC -->
- [SprtaItemSimulator](#sprtaitemsimulator)
- [핵심 문서](#핵심-문서)
- [프로젝트 구조](#프로젝트-구조)
  - [Docs (문서)](#docs-문서)
  - [Logs (로그)](#logs-로그)
  - [Node Modules (노드 모듈)](#node-modules-노드-모듈)
  - [Prisma (프리즈마)](#prisma-프리즈마)
  - [Src (소스)](#src-소스)
  - [앱 관련 파일](#앱-관련-파일)
  - [Docker 및 설정 파일](#docker-및-설정-파일)
  - [루트 파일](#루트-파일)
- [TODO](#todo)
  - [API](#api)
    - [유저](#유저)
    - [캐릭터](#캐릭터)
    - [아이템 관리](#아이템-관리)
    - [아이템 관련](#아이템-관련)
- [사전 질문에 대한 답변](#사전-질문에-대한-답변)
- [비밀번호 해싱 관련 질문](#비밀번호-해싱-관련-질문)
  - [질문 1: 비밀번호를 DB에 저장할 때 Hash를 이용했는데, Hash는 단방향 암호화와 양방향 암호화 중 어떤 암호화 방식에 해당할까요?](#질문-1-비밀번호를-db에-저장할-때-hash를-이용했는데-hash는-단방향-암호화와-양방향-암호화-중-어떤-암호화-방식에-해당할까요)
  - [질문 2: 비밀번호를 그냥 저장하지 않고 Hash 한 값을 저장했을 때의 장점은 무엇인가요?](#질문-2-비밀번호를-그냥-저장하지-않고-hash-한-값을-저장했을-때의-장점은-무엇인가요)
- [JWT 인증 관련 질문](#jwt-인증-관련-질문)
  - [질문 3: Access Token이 노출되었을 경우 발생할 수 있는 문제점은 무엇인가요? 이를 보완하기 위한 방법은 어떤 것이 있을까요?](#질문-3-access-token이-노출되었을-경우-발생할-수-있는-문제점은-무엇인가요-이를-보완하기-위한-방법은-어떤-것이-있을까요)
- [인증과 인가 관련 질문](#인증과-인가-관련-질문)
  - [질문 4: 인증과 인가란 무엇인가요? API에서 인증이 필요한 API와 그렇지 않은 API의 차이는 무엇인가요?](#질문-4-인증과-인가란-무엇인가요-api에서-인증이-필요한-api와-그렇지-않은-api의-차이는-무엇인가요)
- [아이템 관련 질문](#아이템-관련-질문)
  - [질문 5: 아이템 생성, 수정 API는 인증이 필요하지 않다고 했지만, 왜 사실 인증이 필요한 API인가요?](#질문-5-아이템-생성-수정-api는-인증이-필요하지-않다고-했지만-왜-사실-인증이-필요한-api인가요)
  - [질문 6: 캐릭터 테이블에 `money`라는 게임 머니 컬럼만 추가했을 때의 단점은 무엇인가요? 이를 보완할 수 있는 방법은 무엇인가요?](#질문-6-캐릭터-테이블에-money라는-게임-머니-컬럼만-추가했을-때의-단점은-무엇인가요-이를-보완할-수-있는-방법은-무엇인가요)
    - [단점:](#단점)
    - [보완 방법:](#보완-방법)
  - [질문 7: 아이템 구입 시에 가격을 클라이언트에서 입력하게 하면 어떠한 문제점이 있을까요?](#질문-7-아이템-구입-시에-가격을-클라이언트에서-입력하게-하면-어떠한-문제점이-있을까요)
    - [해결 방법:](#해결-방법)
- [HTTP Status Code 관련 질문](#http-status-code-관련-질문)
  - [질문 8: 과제를 진행하면서 사용한 Http Status Code를 모두 나열하고, 각각이 의미하는 것과 어떤 상황에 사용했는지 작성해 주세요.](#질문-8-과제를-진행하면서-사용한-http-status-code를-모두-나열하고-각각이-의미하는-것과-어떤-상황에-사용했는지-작성해-주세요)

<!-- /TOC -->

# 핵심 문서
- [next()를 두번 호출해야 결과를 반환해주던 문제](./Docs/TroubleShooting/twiceNextCallProblem.md)
- [API 명세서](./Docs/APIs.md)

# 프로젝트 구조

```bash
📁 Project Root
│
├── 📁 Docs
│   ├── TroubleShooting/
│   │   └── twiceNextCallProblem.md
│   └── APIs.md
│
├── 📁 logs
│
├── 📁 node_modules
│
├── 📁 prisma
│
├── 📁 src
│   ├── 📁 design-patterns
│   ├── 📁 errors
│   ├── 📁 lib
│   ├── 📁 middleware
│   ├── 📁 repositories
│   ├── 📁 routes
│   ├── 📁 services
│   └── 📁 test
│
├── app.js
├── .dockerignore
├── .env
├── .gitignore
├── .prettierrc
├── docker-compose.yml
├── Dockerfile
├── jsdoc.json
├── launch.json
├── nodemon.json
├── LICENSE
├── README.md
├── package.json
└── yarn.lock
```

## Docs (문서)
- **TroubleShooting/**: 문제 해결을 위한 가이드가 포함된 디렉토리입니다.
  - `twiceNextCallProblem.md`: Next.js 호출 문제와 관련된 구체적인 문서.
- **APIs.md**: API 엔드포인트에 대한 문서입니다.

## Logs (로그)
- **logs/**: (현재 비어있거나 애플리케이션에서 생성된 로그가 들어갑니다)

## Node Modules (노드 모듈)
- **node_modules/**: 프로젝트의 의존성(dependencies)을 포함하는 디렉토리입니다.

## Prisma (프리즈마)
- **prisma/**: 데이터베이스 관리를 위한 Prisma 스키마 파일과 마이그레이션 파일이 들어있는 디렉토리입니다.

## Src (소스)
- **src/**: 메인 소스 코드 디렉토리.
  - **design-patterns/**: 디자인 패턴 및 아키텍처 참조 파일들.
  - **errors/**: 커스텀 에러 핸들링 클래스와 유틸리티.
  - **lib/**: 유틸리티 라이브러리 및 헬퍼 함수들.
  - **middleware/**: 인증, 토큰 검증, 역할 확인을 위한 미들웨어들.
  - **repositories/**: 아이템, 사용자, 캐릭터 등의 데이터베이스 작업을 처리하는 디렉토리.
  - **routes/**: 다양한 기능 (예: 아이템 관리, 사용자 인증)을 위한 API 경로를 정의한 파일들.
  - **services/**: 요청을 처리하고, 리포지토리와 상호작용하며 응답을 반환하는 비즈니스 로직을 포함.
  - **test/**: 유닛 및 통합 테스트 파일들이 포함된 디렉토리.

## 앱 관련 파일
- **app.js**: 애플리케이션의 메인 진입점 파일.

## Docker 및 설정 파일
- **.dockerignore**: Docker에서 무시할 파일 및 디렉토리를 지정합니다.
- **.env**: 환경 변수(예: 데이터베이스 자격 증명, API 키 등)를 포함한 파일입니다.
- **.gitignore**: Git에서 무시할 파일 및 디렉토리를 지정합니다.
- **.prettierrc**: Prettier 코드 포매터의 설정 파일입니다.
- **docker-compose.yml**: Docker Compose에서 사용되는 서비스, 네트워크 및 볼륨을 정의한 파일입니다.
- **Dockerfile**: 애플리케이션의 Docker 이미지를 빌드하기 위한 지침 파일입니다.
- **jsdoc.json**: JSDoc을 사용해 소스 코드에서 문서를 생성하기 위한 설정 파일입니다.
- **launch.json**: 프로젝트를 시작하고 디버깅하기 위한 설정 파일입니다.
- **nodemon.json**: 개발 중 서버를 자동으로 재시작하기 위한 Nodemon 설정 파일입니다.

## 루트 파일
- **LICENSE**: 프로젝트의 라이선스 파일입니다.
- **README.md**: 프로젝트 설정 및 실행 방법을 설명하는 메인 문서입니다.
- **package.json**: 프로젝트의 의존성, 스크립트, 메타데이터가 포함된 파일입니다.
- **yarn.lock**: Yarn이 의존성을 일관되게 설치하도록 하는 잠금 파일입니다.




# TODO

## API

> **Tag**  
> A -> 인증 필요  
> P -> Post  
> D -> Delete  
> G -> Get  
> U -> pUt  
> T -> paTch


### 유저
- [x] 회원가입(P) : ID(영어 + 숫자 5글자 이상), PW(영어 + 숫자 + 특수문자 6글자 이상), 닉네임(한글 기준 16글자)
- [x] 로그인(P)
- [x] 회원탈퇴(AD)
- [x] 비밀번호 변경(AT)
- [x] 토큰 재 요청(P)
- [x] 유저 권한 변경(AT) : 관리자 계정으로만 가능
- [x] 로그아웃(AP)

### 캐릭터
- [x] 캐릭터 생성 (AP) : 본인 계정에서 캐릭터 생성
- [x] 캐릭터 삭제 (AD) : 본인 계정에서 캐릭터 삭제
- [x] 캐릭터 이름 변경 (AT) : 본인 계정에서 캐릭터 변경
- [x] 캐릭터 선택 (AP) : 본인 계정에서 사용할 캐릭터 선택
- [x] 캐릭터 정보 ({A}P) : 인증 없이 조회시 이름과 스탯만, 인증 및 본인 캐릭터 조회시 보유 머니 및 인벤토리 반환

### 아이템 관리
> 관리자 전용 API

- [x] 신규 등록(AP)
- [x] 수정(AT) : 아이템 가격 수정 불가
- [x] 삭제(AD)

### 아이템 관련
- [X] 아이템 목록(AG) : 선택된 캐릭터의 보유 아이템 목록(인벤토리) 반환, Page 지정 가능(페이지당 갯수, 몇 페이지 인지)
- [x] 아이템 검색(G) : 소유자가 없는 아이템 목록 중 검색합니다. 아이템 코드, 이름, 스탯, 장비여부, 최소 가격, 페이지 지정 가능
- [x] 아이템 구매(AP) : 관리자는 비용 없이 구매 가능, 사용자는 비용 지불 후 구매 가능
- [x] 아이템 판매(AP) : 관리자는 아이템 삭제만, 사용자는 원가의 60% 가격으로 정산
- [x] 아이템 장착(AP) : 스탯이 반영 되어야 함
- [x] 아이템 해제(AP) : 스탯이 반영 되어야 함
- [x] 사냥 보상 획득(AP) : 100원 지급 후 보유 머니 반환
  

# 사전 질문에 대한 답변

# 비밀번호 해싱 관련 질문

## 질문 1: 비밀번호를 DB에 저장할 때 Hash를 이용했는데, Hash는 단방향 암호화와 양방향 암호화 중 어떤 암호화 방식에 해당할까요?
- **답변**: Hash는 **단방향 암호화**에 해당합니다. 한 번 변환된 값을 원래 값으로 되돌릴 수 없기 때문에 단방향 암호화입니다.

## 질문 2: 비밀번호를 그냥 저장하지 않고 Hash 한 값을 저장했을 때의 장점은 무엇인가요?
- **답변**:
  1. **비밀번호 유출 방지**: 해커가 데이터베이스를 탈취해도, 해시 값만 가져가기 때문에 실제 비밀번호를 알 수 없습니다.
  2. **단방향 특성**: Hash는 원래 값으로 되돌릴 수 없으므로 비밀번호를 역추적할 수 없습니다.
  3. **일관된 저장**: 동일한 입력값은 항상 동일한 Hash 값을 생성하므로, 비밀번호 비교가 용이합니다.
  4. **추가 보안**: Salt와 함께 사용하면, 같은 비밀번호라도 서로 다른 Hash 값을 생성해 보안을 강화할 수 있습니다.

# JWT 인증 관련 질문

## 질문 3: Access Token이 노출되었을 경우 발생할 수 있는 문제점은 무엇인가요? 이를 보완하기 위한 방법은 어떤 것이 있을까요?
- **Access Token 노출 시 발생할 문제점**:
  1. **인증된 사용자로 위장**: 공격자는 노출된 토큰을 사용해 해당 사용자로 인증된 상태로 서버에 요청을 보낼 수 있습니다.
  2. **API 남용**: 공격자가 무단으로 API에 접근하여 민감한 데이터에 접근하거나 권한을 남용할 수 있습니다.
  3. **불법적 활동**: 공격자가 서버 자원을 남용하거나 악의적인 활동에 악용할 수 있습니다.

- **보완 방법**:
  1. **짧은 Access Token 만료 시간 설정**: 토큰이 노출되더라도 사용 기간을 제한하여 피해를 줄일 수 있습니다.
  2. **Refresh Token 사용**: Access Token이 만료되면 사용자가 Refresh Token을 통해 새 Access Token을 발급받도록 합니다.
  3. **IP 및 User-Agent 검사**: 토큰 사용 시 IP 주소나 User-Agent 정보를 비교하여 이상 활동을 감지하고 차단합니다.
  4. **토큰 사용 후 블랙리스트 처리**: 사용된 Access Token을 서버에서 블랙리스트에 추가해 재사용을 방지합니다.
  5. **HTTPS 사용**: 네트워크 상에서 Access Token이 전송될 때 중간에서 탈취되지 않도록 HTTPS로 암호화된 연결을 유지합니다.
  6. **토큰 재발급 시 로그아웃**: 새 토큰 발급 시 기존 토큰을 무효화하거나 전체 세션을 로그아웃 처리합니다.

# 인증과 인가 관련 질문

## 질문 4: 인증과 인가란 무엇인가요? API에서 인증이 필요한 API와 그렇지 않은 API의 차이는 무엇인가요?
- **인증(Authentication)**: 사용자가 누구인지 확인하는 과정입니다. 주로 아이디, 비밀번호, 토큰 등을 사용해 신원을 확인합니다.
- **인가(Authorization)**: 인증된 사용자가 어떤 작업을 수행할 권한이 있는지 확인하는 과정입니다. 특정 리소스나 기능에 접근할 수 있는 권한을 부여합니다.

- **인증이 필요한 API**: 사용자의 신원을 확인한 후에만 접근할 수 있는 API입니다. 예를 들어, 사용자 정보 수정이나 민감한 데이터 접근을 요구하는 경우 인증이 필수입니다.
- **인증이 필요하지 않은 API**: 공개된 데이터를 제공하거나, 모든 사용자가 접근할 수 있는 기능을 제공하는 API입니다. 예를 들어, 아이템 목록 조회 등은 인증이 필요하지 않을 수 있습니다.

# 아이템 관련 질문

## 질문 5: 아이템 생성, 수정 API는 인증이 필요하지 않다고 했지만, 왜 사실 인증이 필요한 API인가요?
- **답변**:
  - **데이터 무결성**: 아이템 생성 및 수정은 시스템의 중요한 데이터를 변경하므로 인증이 필요합니다. 인증되지 않은 사용자가 이 API에 접근하면 데이터 변조의 위험이 있습니다.
  - **권한 관리**: 아이템 생성 및 수정은 일반 사용자가 아닌 **관리자**나 **특정 권한을 가진 사용자**만 할 수 있어야 합니다.
  - **악의적 공격 방지**: 인증이 없으면 악의적인 사용자가 데이터를 임의로 변경하여 시스템의 보안을 위협할 수 있습니다.

## 질문 6: 캐릭터 테이블에 `money`라는 게임 머니 컬럼만 추가했을 때의 단점은 무엇인가요? 이를 보완할 수 있는 방법은 무엇인가요?
- **답변**:
  ### 단점:
  1. **확장성 부족**: 다양한 자산이나 화폐를 관리할 수 없고, 새로운 자산이 추가될 때마다 테이블 구조를 수정해야 합니다.
  2. **트랜잭션 추적 어려움**: 게임 내에서 자산의 변동 내역을 기록할 수 없어, 금액이 변동된 이유를 추적하기 어렵습니다.
  3. **데이터 무결성 문제**: 단순한 `money` 컬럼 업데이트로 인한 오류 발생 시 금액 손실 등이 발생할 수 있습니다.

  ### 보완 방법:
  1. **트랜잭션 테이블 추가**: 자산의 변동 내역을 기록하는 트랜잭션 테이블을 추가하여 모든 금전적 활동을 추적할 수 있습니다.
  2. **자산 테이블 분리**: 캐릭터의 다양한 자산을 별도의 테이블로 분리하여 관리하고, 새로운 자산이 추가될 때에도 유연하게 대응할 수 있습니다.
  3. **이벤트 기반 로그 시스템**: 자산 변동과 관련된 이벤트 로그 시스템을 구축하여 각 이벤트에 따른 금전적 변동을 기록하고 추적할 수 있습니다.

## 질문 7: 아이템 구입 시에 가격을 클라이언트에서 입력하게 하면 어떠한 문제점이 있을까요?
- **답변**:
  1. **가격 변조 위험**: 클라이언트에서 가격을 임의로 낮게 설정하여 부당하게 아이템을 구매할 수 있습니다.
  2. **보안 취약점**: 클라이언트에서 중요한 정보를 관리하게 되면 가격 변조가 발생할 위험이 커집니다.
  3. **서버 신뢰성 저하**: 클라이언트가 조작한 데이터를 서버가 신뢰하게 되어, 서버의 무결성이 손상될 수 있습니다.
  4. **정책 위반 및 부정 거래**: 클라이언트가 가격을 조정함으로써 게임 운영 정책에 위반되는 거래가 발생할 수 있습니다.

  ### 해결 방법:
  1. **가격을 서버에서 관리**: 아이템 가격을 서버에서 결정하고 클라이언트는 서버의 가격 정보를 기반으로 구매 요청을 보냅니다.
  2. **서버 측 검증**: 클라이언트가 보낸 구매 요청 시 서버에서 아이템 가격을 검증하여 변조 여부를 확인합니다.
  3. **아이템 정보 캐싱**: 클라이언트는 가격 정보를 캐싱할 수 있지만, 최종 검증과 결제는 서버에서 처리합니다.

# HTTP Status Code 관련 질문

## 질문 8: 과제를 진행하면서 사용한 Http Status Code를 모두 나열하고, 각각이 의미하는 것과 어떤 상황에 사용했는지 작성해 주세요.
- **답변**:
  - **500 (Internal Server Error)**: 서버 내에서 정의되지 않은 에러가 발생했을 때 사용. 에러 내역을 감추기 위해 사용함.
  - **404 (Not Found)**: 요청한 리소스를 찾을 수 없을 때 사용.
  - **403 (Forbidden)**: 인가되지 않은 사용자에게 접근 권한이 없을 때 사용.
  - **401 (Unauthorized)**: 인증되지 않은 사용자에게 접근 권한이 없을 때 사용.
  - **400 (Bad Request)**: 클라이언트에서 잘못된 요청을 보냈을 때 사용.
  - **200 (OK)**: 요청이 성공적으로 처리되었을 때 사용.